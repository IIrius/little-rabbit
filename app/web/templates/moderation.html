<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{{ app_name }} · Moderation Console</title>
    <style>
        :root {
            color-scheme: light dark;
            --bg: #0f172a;
            --panel: #1e293b;
            --accent: #38bdf8;
            --accent-strong: #0ea5e9;
            --border: rgba(148, 163, 184, 0.25);
            --text: #e2e8f0;
            --muted: #94a3b8;
            --danger: #fb7185;
            --success: #34d399;
        }

        body {
            margin: 0;
            font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(145deg, rgba(14, 23, 42, 0.94), rgba(15, 23, 42, 1));
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 1.5rem clamp(1rem, 2vw, 2.5rem);
            border-bottom: 1px solid var(--border);
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
        }

        header h1 {
            margin: 0;
            font-size: clamp(1.6rem, 2.5vw, 2.2rem);
            font-weight: 700;
        }

        header p {
            margin: 0.35rem 0 0;
            color: var(--muted);
        }

        main {
            flex: 1;
            display: grid;
            grid-template-columns: minmax(280px, 2fr) minmax(260px, 1.4fr);
            gap: clamp(1rem, 3vw, 2rem);
            padding: clamp(1rem, 3vw, 2.5rem);
        }

        section, aside {
            background: rgba(15, 23, 42, 0.82);
            border: 1px solid var(--border);
            border-radius: 18px;
            padding: clamp(1rem, 2vw, 1.75rem);
            box-shadow: 0 30px 80px rgba(10, 12, 20, 0.45);
            position: relative;
            overflow: hidden;
        }

        section::after, aside::after {
            content: "";
            position: absolute;
            inset: 0;
            pointer-events: none;
            background: radial-gradient(circle at top right, rgba(56, 189, 248, 0.13), transparent 45%);
        }

        h2 {
            margin: 0;
            font-size: clamp(1.1rem, 2vw, 1.4rem);
            font-weight: 600;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: clamp(1rem, 2vw, 1.5rem);
        }

        .panel-header span {
            color: var(--muted);
            font-size: 0.9rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.08em;
            color: var(--muted);
        }

        th, td {
            padding: 0.65rem 0.45rem;
            text-align: left;
            border-bottom: 1px solid rgba(148, 163, 184, 0.08);
        }

        tbody tr {
            transition: background 0.2s ease;
            cursor: pointer;
        }

        tbody tr:hover {
            background: rgba(56, 189, 248, 0.08);
        }

        tbody tr.selected {
            background: rgba(56, 189, 248, 0.14);
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.25rem 0.65rem;
            border-radius: 999px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .badge.pending {
            color: #fcd34d;
            background: rgba(252, 211, 77, 0.12);
        }

        .badge.approved {
            color: var(--success);
            background: rgba(52, 211, 153, 0.12);
        }

        .badge.rejected {
            color: var(--danger);
            background: rgba(251, 113, 133, 0.12);
        }

        .action-bar {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        button {
            border: none;
            border-radius: 12px;
            padding: 0.65rem 1.1rem;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.9rem;
            transition: transform 0.15s ease, box-shadow 0.2s ease;
        }

        button.primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-strong));
            color: #081028;
            box-shadow: 0 12px 30px rgba(14, 165, 233, 0.35);
        }

        button.secondary {
            background: rgba(148, 163, 184, 0.12);
            color: var(--text);
        }

        button.danger {
            background: rgba(251, 113, 133, 0.22);
            color: var(--danger);
        }

        button.success {
            background: rgba(52, 211, 153, 0.18);
            color: var(--success);
        }

        button:disabled {
            opacity: 0.45;
            cursor: not-allowed;
            box-shadow: none;
        }

        button:not(:disabled):hover {
            transform: translateY(-1px);
        }

        .detail-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 0.75rem;
        }

        .detail-header h3 {
            margin: 0;
            font-size: 1.05rem;
        }

        .ai-insights {
            margin: 1.2rem 0;
            padding: 0.9rem 1rem;
            border-radius: 14px;
            background: rgba(56, 189, 248, 0.1);
            border: 1px solid rgba(56, 189, 248, 0.2);
        }

        .ai-insights strong {
            font-size: 0.95rem;
        }

        .ai-flags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.45rem;
            margin-top: 0.8rem;
        }

        .ai-flag {
            background: rgba(56, 189, 248, 0.2);
            color: var(--accent);
            padding: 0.3rem 0.6rem;
            border-radius: 10px;
            font-size: 0.75rem;
        }

        textarea {
            width: 100%;
            min-height: 80px;
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: rgba(15, 23, 42, 0.6);
            color: inherit;
            padding: 0.75rem;
            font-size: 0.95rem;
            resize: vertical;
        }

        .history-list {
            margin: 0;
            padding: 0;
            list-style: none;
            display: grid;
            gap: 0.8rem;
        }

        .history-item {
            padding: 0.75rem 0.9rem;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.15);
            display: flex;
            justify-content: space-between;
            gap: 1rem;
        }

        .history-item small {
            color: var(--muted);
            display: block;
            margin-top: 0.3rem;
        }

        .notification-banner {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.85rem 1.35rem;
            border-radius: 14px;
            background: rgba(56, 189, 248, 0.9);
            color: #0b1121;
            font-weight: 600;
            box-shadow: 0 18px 40px rgba(14, 165, 233, 0.28);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .notification-banner.visible {
            opacity: 1;
            pointer-events: auto;
        }

        @media (max-width: 1024px) {
            main {
                grid-template-columns: 1fr;
            }

            aside {
                order: -1;
            }
        }
    </style>
</head>
<body data-testid="moderation-console">
    <header>
        <h1>Moderation Console</h1>
        <p>Review AI flagged content across workspaces · {{ app_name }}</p>
    </header>

    <main>
        <section id="queue-panel" data-testid="moderation-queue">
            <div class="panel-header">
                <div>
                    <h2>Queue</h2>
                    <span id="queue-count">0 items awaiting review</span>
                </div>
                <div class="action-bar">
                    <button id="bulk-approve" class="success" disabled>Approve selected</button>
                    <button id="bulk-reject" class="danger" disabled>Reject selected</button>
                    <button id="refresh-queue" class="secondary">Refresh</button>
                </div>
            </div>

            <table aria-describedby="queue-count">
                <thead>
                    <tr>
                        <th title="Select request"></th>
                        <th>Title</th>
                        <th>Workspace</th>
                        <th>AI score</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="queue-body"></tbody>
            </table>
            <p id="queue-empty" style="display: none; color: var(--muted); margin-top: 1rem;">No content currently requires moderation.</p>
        </section>

        <aside id="details-panel" data-testid="moderation-details">
            <div class="detail-header">
                <div>
                    <h3 id="details-title">Select an item to view details</h3>
                    <small id="details-workspace"></small>
                </div>
                <span id="details-status" class="badge pending" style="display:none;">Pending</span>
            </div>

            <div class="ai-insights" style="display:none;" id="details-analysis">
                <strong>AI analysis</strong>
                <p id="details-summary"></p>
                <div class="ai-flags" id="details-flags"></div>
            </div>

            <article style="margin-bottom: 1.15rem;">
                <h4 style="margin: 0 0 0.6rem 0; font-size: 0.9rem; color: var(--muted);">Content excerpt</h4>
                <p id="details-excerpt" style="margin: 0; line-height: 1.5; white-space: pre-wrap;"></p>
            </article>

            <label for="decision-reason" style="display:block; margin-bottom: 0.35rem; font-weight: 600;">Moderator notes</label>
            <textarea id="decision-reason" placeholder="Add context for this decision (optional)"></textarea>

            <div class="action-bar" style="margin-top: 1.05rem;">
                <button id="approve-single" class="success" disabled>Approve</button>
                <button id="reject-single" class="danger" disabled>Reject</button>
                <button id="clear-selection" class="secondary" disabled>Clear selection</button>
            </div>
        </aside>

        <section id="history-panel" data-testid="moderation-history">
            <div class="panel-header">
                <div>
                    <h2>Recent decisions</h2>
                    <span>Filter by status</span>
                </div>
                <div class="action-bar">
                    <select id="history-status" style="padding: 0.5rem 0.75rem; border-radius: 12px; border: 1px solid rgba(148, 163, 184, 0.35); background: rgba(15, 23, 42, 0.6); color: inherit;">
                        <option value="">All</option>
                        <option value="approved">Approved</option>
                        <option value="rejected">Rejected</option>
                    </select>
                    <button id="refresh-history" class="secondary">Refresh</button>
                </div>
            </div>
            <ul class="history-list" id="history-list"></ul>
            <p id="history-empty" style="display:none; color: var(--muted); margin-top: 1rem;">No recent moderation decisions recorded.</p>
        </section>
    </main>

    <div class="notification-banner" id="notification-banner" role="status" aria-live="polite"></div>

    <template id="queue-row-template">
        <tr>
            <td><input type="checkbox" class="queue-checkbox" aria-label="Select request" /></td>
            <td class="queue-title"></td>
            <td class="queue-workspace"></td>
            <td class="queue-score"></td>
            <td><span class="badge pending">Pending</span></td>
        </tr>
    </template>

    <template id="history-item-template">
        <li class="history-item">
            <div>
                <strong class="history-title"></strong>
                <small class="history-meta"></small>
                <p class="history-reason" style="margin: 0.35rem 0 0 0;"></p>
            </div>
            <span class="badge">Decision</span>
        </li>
    </template>

    <script>
        const queueBody = document.getElementById("queue-body");
        const queueEmpty = document.getElementById("queue-empty");
        const queueCount = document.getElementById("queue-count");

        const detailsTitle = document.getElementById("details-title");
        const detailsWorkspace = document.getElementById("details-workspace");
        const detailsStatus = document.getElementById("details-status");
        const detailsSummary = document.getElementById("details-summary");
        const detailsExcerpt = document.getElementById("details-excerpt");
        const detailsAnalysis = document.getElementById("details-analysis");
        const detailsFlags = document.getElementById("details-flags");
        const moderatorNotes = document.getElementById("decision-reason");

        const approveSingle = document.getElementById("approve-single");
        const rejectSingle = document.getElementById("reject-single");
        const clearSelection = document.getElementById("clear-selection");
        const bulkApprove = document.getElementById("bulk-approve");
        const bulkReject = document.getElementById("bulk-reject");
        const refreshQueue = document.getElementById("refresh-queue");

        const historyList = document.getElementById("history-list");
        const historyEmpty = document.getElementById("history-empty");
        const historyStatus = document.getElementById("history-status");
        const refreshHistory = document.getElementById("refresh-history");

        const notificationBanner = document.getElementById("notification-banner");

        const API_BASE = "/api/moderation";
        const QUEUE_ENDPOINT = "/api/moderation/queue";
        const HISTORY_ENDPOINT = "/api/moderation/history";
        const REQUESTS_ENDPOINT = "/api/moderation/requests";
        const WS_ENDPOINT = "/api/moderation/notifications";
        const queueTemplate = document.getElementById("queue-row-template");
        const historyTemplate = document.getElementById("history-item-template");

        const requestCache = new Map();
        const selectedRequests = new Set();
        let activeRequestId = null;

        function formatScore(value) {
            return typeof value === "number" ? value.toFixed(2) : "–";
        }

        function formatTimestamp(value) {
            try {
                return new Intl.DateTimeFormat(undefined, {
                    dateStyle: "medium",
                    timeStyle: "short"
                }).format(new Date(value));
            } catch (error) {
                return value;
            }
        }

        function updateSelectionState() {
            const hasSelection = selectedRequests.size > 0;
            bulkApprove.disabled = !hasSelection;
            bulkReject.disabled = !hasSelection;
            clearSelection.disabled = !hasSelection;
            approveSingle.disabled = !activeRequestId;
            rejectSingle.disabled = !activeRequestId;
        }

        function clearSelections() {
            selectedRequests.clear();
            activeRequestId = null;
            Array.from(queueBody.querySelectorAll("tr")).forEach((row) => {
                row.classList.remove("selected");
                const checkbox = row.querySelector("input[type='checkbox']");
                if (checkbox) checkbox.checked = false;
            });
            resetDetails();
            updateSelectionState();
        }

        function resetDetails() {
            detailsTitle.textContent = "Select an item to view details";
            detailsWorkspace.textContent = "";
            detailsStatus.style.display = "none";
            detailsStatus.textContent = "Pending";
            detailsStatus.className = "badge pending";
            detailsSummary.textContent = "";
            detailsExcerpt.textContent = "";
            detailsFlags.innerHTML = "";
            detailsAnalysis.style.display = "none";
        }

        function renderQueue(items) {
            queueBody.innerHTML = "";
            if (!items.length) {
                queueEmpty.style.display = "block";
                queueCount.textContent = "0 items awaiting review";
                return;
            }
            queueEmpty.style.display = "none";
            queueCount.textContent = `${items.length} item${items.length > 1 ? "s" : ""} awaiting review`;

            const availableIds = new Set(items.map((entry) => entry.id));
            Array.from(selectedRequests).forEach((id) => {
                if (!availableIds.has(id)) {
                    selectedRequests.delete(id);
                }
            });

            items.forEach((item) => {
                requestCache.set(item.id, item);
                const fragment = queueTemplate.content.cloneNode(true);
                const row = fragment.querySelector("tr");
                const checkbox = fragment.querySelector(".queue-checkbox");
                const title = fragment.querySelector(".queue-title");
                const workspace = fragment.querySelector(".queue-workspace");
                const score = fragment.querySelector(".queue-score");
                const statusBadge = fragment.querySelector(".badge");

                title.textContent = item.content_title;
                workspace.textContent = item.workspace;
                score.textContent = formatScore(item.ai_analysis.score);
                statusBadge.textContent = item.status;
                statusBadge.className = `badge ${item.status}`;

                checkbox.checked = selectedRequests.has(item.id) || item.id === activeRequestId;
                if (checkbox.checked) {
                    row.classList.add("selected");
                    selectedRequests.add(item.id);
                }

                checkbox.addEventListener("click", (event) => {
                    event.stopPropagation();
                    if (checkbox.checked) {
                        selectedRequests.add(item.id);
                    } else {
                        selectedRequests.delete(item.id);
                    }
                    row.classList.toggle("selected", checkbox.checked || item.id === activeRequestId);
                    updateSelectionState();
                });

                row.addEventListener("click", () => {
                    activeRequestId = item.id;
                    selectedRequests.add(item.id);
                    Array.from(queueBody.querySelectorAll("tr")).forEach((otherRow) => {
                        otherRow.classList.remove("selected");
                        const otherCheckbox = otherRow.querySelector("input[type='checkbox']");
                        if (otherCheckbox) otherCheckbox.checked = selectedRequests.has(Number(otherCheckbox.dataset.requestId));
                    });
                    row.classList.add("selected");
                    checkbox.checked = true;
                    updateSelectionState();
                    loadRequestDetails(item.id);
                });

                checkbox.dataset.requestId = String(item.id);
                queueBody.appendChild(fragment);
            });
        }

        async function loadQueue() {
            try {
                const response = await fetch(QUEUE_ENDPOINT);
                if (!response.ok) throw new Error("Failed to load queue");
                const payload = await response.json();
                renderQueue(payload);
                if (activeRequestId) {
                    await loadRequestDetails(activeRequestId);
                }
            } catch (error) {
                showNotification(error.message || "Unable to load moderation queue", true);
            }
        }

        async function loadRequestDetails(requestId) {
            try {
                const response = await fetch(`${REQUESTS_ENDPOINT}/${requestId}`);
                if (!response.ok) throw new Error("Request details unavailable");
                const item = await response.json();
                requestCache.set(item.id, item);

                detailsTitle.textContent = item.content_title;
                detailsWorkspace.textContent = `${item.workspace} · ${formatTimestamp(item.submitted_at)}`;

                detailsStatus.style.display = "inline-flex";
                detailsStatus.textContent = item.status;
                detailsStatus.className = `badge ${item.status}`;

                detailsSummary.textContent = item.ai_analysis.summary || "No AI summary provided.";
                detailsExcerpt.textContent = item.content_excerpt || "No excerpt supplied.";

                detailsFlags.innerHTML = "";
                if (item.ai_analysis.flags && item.ai_analysis.flags.length) {
                    detailsAnalysis.style.display = "block";
                    item.ai_analysis.flags.forEach((flag) => {
                        const span = document.createElement("span");
                        span.className = "ai-flag";
                        span.textContent = flag;
                        detailsFlags.appendChild(span);
                    });
                } else {
                    detailsAnalysis.style.display = "block";
                }
            } catch (error) {
                showNotification(error.message || "Unable to load request details", true);
            }
        }

        async function submitDecision(requestIds, decision) {
            const payload = {
                decision,
                actor: "moderation-console",
                reason: moderatorNotes.value.trim() || null,
            };

            if (Array.isArray(requestIds) && requestIds.length === 0) {
                showNotification("Select at least one request to continue", true);
                return;
            }

            try {
                if (Array.isArray(requestIds)) {
                    payload.request_ids = requestIds;
                    const response = await fetch(`${REQUESTS_ENDPOINT}/bulk-decision`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload),
                    });
                    if (!response.ok) {
                        const errorBody = await response.json().catch(() => ({}));
                        throw new Error(errorBody.detail || "Bulk decision failed");
                    }
                } else {
                    const response = await fetch(`${REQUESTS_ENDPOINT}/${requestIds}/decision`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload),
                    });
                    if (!response.ok) {
                        const errorBody = await response.json().catch(() => ({}));
                        throw new Error(errorBody.detail || "Decision failed");
                    }
                }
                showNotification(`Decision recorded: ${decision}`);
                moderatorNotes.value = "";
                selectedRequests.clear();
                updateSelectionState();
                await loadQueue();
                await loadHistory();
            } catch (error) {
                showNotification(error.message || "Unable to update moderation decision", true);
            }
        }

        async function loadHistory() {
            try {
                const params = new URLSearchParams();
                const status = historyStatus.value;
                if (status) params.set("status", status);
                const response = await fetch(`${HISTORY_ENDPOINT}?${params.toString()}`);
                if (!response.ok) throw new Error("Failed to load history");
                const history = await response.json();

                historyList.innerHTML = "";
                if (!history.length) {
                    historyEmpty.style.display = "block";
                    return;
                }
                historyEmpty.style.display = "none";
                history.forEach((entry) => {
                    const fragment = historyTemplate.content.cloneNode(true);
                    const listItem = fragment.querySelector(".history-item");
                    const title = fragment.querySelector(".history-title");
                    const meta = fragment.querySelector(".history-meta");
                    const reason = fragment.querySelector(".history-reason");
                    const badge = fragment.querySelector(".badge");

                    const request = requestCache.get(entry.request_id);
                    title.textContent = request?.content_title || `Request #${entry.request_id}`;
                    meta.textContent = `${entry.decided_by || "Auto"} · ${formatTimestamp(entry.decided_at)}`;
                    reason.textContent = entry.reason || "No moderator notes provided.";

                    badge.textContent = entry.decision;
                    badge.className = `badge ${entry.decision}`;

                    historyList.appendChild(fragment);
                });
            } catch (error) {
                showNotification(error.message || "Unable to load history", true);
            }
        }

        function showNotification(message, isError = false) {
            notificationBanner.textContent = message;
            notificationBanner.classList.toggle("error", isError);
            notificationBanner.classList.add("visible");
            setTimeout(() => {
                notificationBanner.classList.remove("visible");
            }, 3200);
        }

        function connectWebSocket() {
            try {
                const protocol = window.location.protocol === "https:" ? "wss" : "ws";
                const ws = new WebSocket(`${protocol}://${window.location.host}${WS_ENDPOINT}`);

                ws.onmessage = (event) => {
                    try {
                        const payload = JSON.parse(event.data);
                        if (!payload || !payload.type) return;
                        if (payload.type === "moderation.connected") {
                            showNotification("Connected to moderation feed");
                            return;
                        }
                        showNotification("Moderation queue updated");
                        loadQueue();
                        loadHistory();
                    } catch (error) {
                        console.error("Failed to handle notification", error);
                    }
                };

                ws.onclose = () => {
                    setTimeout(connectWebSocket, 4000);
                };
            } catch (error) {
                console.warn("WebSocket connection unavailable", error);
            }
        }

        bulkApprove.addEventListener("click", () => {
            const ids = Array.from(selectedRequests);
            submitDecision(ids, "approved");
        });

        bulkReject.addEventListener("click", () => {
            const ids = Array.from(selectedRequests);
            submitDecision(ids, "rejected");
        });

        approveSingle.addEventListener("click", () => {
            if (activeRequestId) {
                submitDecision(activeRequestId, "approved");
            }
        });

        rejectSingle.addEventListener("click", () => {
            if (activeRequestId) {
                submitDecision(activeRequestId, "rejected");
            }
        });

        clearSelection.addEventListener("click", clearSelections);
        refreshQueue.addEventListener("click", loadQueue);
        refreshHistory.addEventListener("click", loadHistory);
        historyStatus.addEventListener("change", loadHistory);

        document.addEventListener("DOMContentLoaded", () => {
            loadQueue();
            loadHistory();
            connectWebSocket();
        });
    </script>
</body>
</html>
